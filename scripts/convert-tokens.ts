/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, you can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Copyright Oxide Computer Company
 */

/**
 * Utilized by `build_themes.sh` to convert theme token files to generate the files in `styles/themes`
 */
import type { CSSProperties } from 'react'
import type { Config, TransformedToken } from 'style-dictionary'
import StyleDictionary from 'style-dictionary'
import dedent from 'ts-dedent'
import type { KebabCase } from 'type-fest'

const THEMES = ['main', 'blue', 'yellow', 'purple', 'red'] as const

const FONT_FAMILIES = {
  'GT America Mono': '"GT America Mono", monospace',
  "Suisse Int'l":
    'SuisseIntl, -apple-system, BlinkMacSystemFont, Helvetica, Arial, sans-serif',
}

const hexToRGB = (hexColor: string) => {
  return hexColor.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) || []
}

const percentToRem = (value: string) => {
  return parseFloat(value) / 100 + 'rem'
}
const pxToRem = (value: string | number) => parseFloat(value as string) / 16 + 'rem'
const valueToRem = (value: string | number) =>
  typeof value === 'string' && value.includes('%') ? percentToRem(value) : pxToRem(value)

const formatFontClass = (name: string) => {
  return name.replace('-regular', '')
}

const camelCase = (s: string) =>
  s
    .replace(/[\W|_]+/g, ' ')
    .replace(
      /([A-Z])([A-Z]+)/g,
      (_, first, remaining) => `${first}${remaining.toLowerCase()}`,
    )

    .replace(/(?:^\w|[A-Z]|\b\w)/g, (leftTrim, idx) =>
      idx === 0 ? leftTrim.toLowerCase() : leftTrim.toUpperCase(),
    )
    .replace(
      /([A-Z])([A-Z]+)/g,
      (_, first, remaining) => `${first}${remaining.toLowerCase()}`,
    )
    .replace(/\s+/g, '')

const kebabCase = (s: string) =>
  camelCase(s)
    .replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2')
    .toLowerCase()

/**
 * The token build process leaves typography styles in object form while it
 * collapses everything else into individual properties. We pass that object
 * to this function to ensure everything is formatted to `rem` units and to remove
 * and properties that we don't really want or need
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const formatTypographyStyles = (name: string, value: any) => {
  // eslint-disable-next-line no-param-reassign
  name = kebabCase(name)
  if (value === 'none') return null
  switch (name) {
    case 'font-family':
      return [name, FONT_FAMILIES[value]]
    case 'line-height':
      return value === 'AUTO' ? null : [name, valueToRem(value)]
    case 'font-weight': {
      const weight = value.toLowerCase()
      if (weight.includes('light')) {
        return [name, 300]
      } else if (weight.includes('medium')) {
        return [name, 500]
      } else {
        return [name, 400]
      }
    }
    case 'paragraph-spacing':
      return null
    case 'text-case':
      return ['text-transform', value]
    case 'font-size':
    case 'letter-spacing':
      return [name, valueToRem(value)]
    default:
      return [name, value]
  }
}

StyleDictionary.registerFormat({
  name: 'theme',
  formatter({ dictionary, options }) {
    /** Used with the `??` operator when you only want to include styles on the root stylesheet */
    const root = options.selector === ':root' ? undefined : ''

    const p3Var = (name: string, color: number[], alpha?: number) =>
      `--${name}-p3: color(display-p3 ${(color[0] / 255).toFixed(4)} ${(
        color[1] / 255
      ).toFixed(4)} ${(color[2] / 255).toFixed(4)}${alpha ? ` / ${alpha}` : ''})`

    return dedent`
		/* THIS FILE IS AUTOGENERATED, DO NOT EDIT */

		${options.selector} {
			${dictionary.allProperties
        .filter((prop) => typeof prop.value !== 'object' && prop.type === 'color')
        .sort(({ name }) => (name.startsWith('base-') ? -1 : 1))
        .map((prop) => {
          const color: string = prop.value.slice(1, 7)
          const rgbColor = hexToRGB(color)
          const { alpha, hasAlpha } = prop.attributes || {}
          if (!rgbColor) {
            throw new Error(
              `Invalid color for ${prop.name}. Expected a hex value, got '${prop.value}'`,
            )
          }
          if (prop.name.startsWith('base-')) {
            return options.selector === ':root'
              ? `--${prop.name}-rgb: ${rgbColor}; /* ${prop.value} */
              ${p3Var(prop.name, rgbColor)};
              --${prop.name}: rgb(var(--${prop.name}-rgb));
              `
              : ''
          }
          if (prop.name.startsWith('theme-')) {
            return `
							--${prop.name}-rgb: var(--${prop.attributes?.ref}-rgb);
              --${prop.name}-p3: var(--${prop.attributes?.ref}-p3);
							--${prop.name}: rgb(var(--${prop.name}-rgb));
						`
          }
          if (hasAlpha && prop.attributes?.ref) {
            return `--${prop.name}: rgba(var(--${prop.attributes?.ref}-rgb), ${alpha});
            ${p3Var(prop.name, rgbColor, alpha)};`
          }
          if (prop.attributes?.ref) {
            return `
							--${prop.name}-rgb: var(--${prop.attributes?.ref}-rgb);
              --${prop.name}-p3: var(--${prop.attributes?.ref}-p3);
							--${prop.name}: rgb(var(--${prop.name}-rgb));
						`
          }
          if (hasAlpha) {
            return `--${prop.name}: rgba(${rgbColor}-rgb, ${alpha});
            ${p3Var(prop.name, rgbColor, alpha)};`
          }
          return `
						--${prop.name}-rgb: ${rgbColor};
            ${p3Var(prop.name, rgbColor)};
						--${prop.name}: rgb(var(--${prop.name}-rgb));
					`
        })
        .join('\n')}

			${
        root ??
        dictionary.allProperties
          .filter((prop) => prop.type === 'borderRadius')
          .map((prop) => {
            return `--${prop.name}: ${prop.value};`
          })
          .join('\n')
      }

      ${
        root ??
        dictionary.allProperties
          .filter((prop) => prop.type === 'boxShadow')
          .map((prop) => {
            return `--${prop.name}: ${[prop.value]
              .flat()
              .map((v) =>
                typeof v === 'object' ? `${v.x}px ${v.y}px ${v.blur}px ${v.color}` : v,
              )};`
          })
          .join('\n')
      }

		}\n`
  },
})

type CSSProperty = KebabCase<keyof CSSProperties> | `--${string}`
/**
 * A helper used by the tailwind formatter, it generates custom tailwind utilities for color styles
 *
 * @param tokenPrefix  The prefix of the color token name to be targeted / replaced
 * @param classPrefix  What will ultimately be prepended to the tailwind class
 * @param cssProperties  The css property name to be output in the generated class
 * @param isP3  Adds `-p3` to the token (optional)
 */
const makeColorUtility = (
  tokenPrefix: 'surface' | 'content' | 'stroke' | 'chart-fill' | 'chart-stroke' | 'theme',
  classPrefix: string,
  cssProperties: CSSProperty | CSSProperty[],
  isP3: boolean,
) => {
  const properties = Array.isArray(cssProperties) ? cssProperties : [cssProperties]
  const tokenSuffix = isP3 === true ? '-p3' : ''
  return (colors: TransformedToken[]) =>
    colors
      .filter((color) => color.name.startsWith(tokenPrefix))
      .map(
        (color) => `${
          (color.original.description &&
            // FIXME: Remove replace once https://github.com/tailwindlabs/tailwindcss/issues/7420 is fixed
            `
            /* ${color.original.description.trim()} */
            `.replace(/,/g, ';')) ||
          ''
        }'.${color.name.replace(tokenPrefix, classPrefix)}': {
					${properties.map((prop) => `'${prop}': 'var(--${color.name}${tokenSuffix})'`)}
				}`,
      )
}

StyleDictionary.registerFormat({
  name: 'tailwind',
  formatter({ dictionary }) {
    const typeStyles = dictionary.allProperties.filter((prop) => prop.type === 'typography')
    const colors = dictionary.allProperties.filter(
      (prop) => prop.type === 'color' && !prop.name.startsWith('base'),
    )
    const borderRadius = dictionary.allProperties.filter(
      (prop) => prop.type === 'borderRadius',
    )
    const boxShadow = dictionary.allProperties.filter((prop) => prop.type === 'boxShadow')

    const makeColors = (isP3: boolean) =>
      `${[
        makeColorUtility('content', 'text', 'color', isP3),
        makeColorUtility('theme', 'text', 'color', isP3),
        makeColorUtility('surface', 'bg', 'background-color', isP3),
        makeColorUtility('theme', 'bg', 'background-color', isP3),
        makeColorUtility('stroke', 'border', 'border-color', isP3),
        makeColorUtility('stroke', 'border-l', 'border-left-color', isP3),
        makeColorUtility('stroke', 'border-r', 'border-right-color', isP3),
        makeColorUtility('stroke', 'border-t', 'border-top-color', isP3),
        makeColorUtility('stroke', 'border-b', 'border-bottom-color', isP3),
        makeColorUtility(
          'stroke',
          'border-x',
          ['border-left-color', 'border-right-color'],
          isP3,
        ),
        makeColorUtility(
          'stroke',
          'border-y',
          ['border-top-color', 'border-bottom-color'],
          isP3,
        ),
        makeColorUtility('stroke', 'ring', '--tw-ring-color', isP3),
        makeColorUtility('stroke', 'outline', 'outline-color', isP3),
        makeColorUtility('chart-fill', 'chart-fill', 'fill', isP3),
        makeColorUtility('chart-stroke', 'chart-stroke', 'stroke', isP3),
      ].map((make) => make(colors))}`

    return `
			/* THIS FILE IS AUTOGENERATED, DO NOT EDIT */

			module.exports.textUtilities = {
				${typeStyles.map(
          (prop) => `
					'.text-${formatFontClass(prop.name)}': {
						${Object.entries(prop.value)
              .map(([name, value]) => formatTypographyStyles(name, value))
              .filter((style) => style !== null)
              // @ts-expect-error null is filtered despite showing up in the types
              .map(([name, value]) => `'${name}': ${JSON.stringify(value)},`)
              .join('\n')}
					}`,
        )}
			}

			module.exports.colorUtilities = {
				${makeColors(false)},
        
        /* Display-P3 color, when supported. */
        '@supports (color: color(display-p3 1 1 1))': {
          ${makeColors(true)}
        }
			}
      
      module.exports.elevationUtilities = {
        ${boxShadow
          .map(
            ({ name }, index) =>
              `'.elevation-${index}': {
                'box-shadow': 'var(--${name})',
              }`,
          )
          .join(',\n')}
      }

			module.exports.borderRadiusTokens = {
				${borderRadius
          .map(
            ({ name }) =>
              `'${name.replace(/border-radius-?/, '') || 'DEFAULT'}': 'var(--${name})'`,
          )
          .join(',')}
			}
		`
  },
})

type ColorGroup = { [colorValue: string]: TransformedToken[] }
StyleDictionary.registerFormat({
  name: 'mermaid',
  formatter({ dictionary, options }) {
    const { name } = options
    const colors = dictionary.allProperties
      .filter((prop) => prop.type === 'color')
      .sort(({ name }) => (name.startsWith('base-') ? -1 : 1))
    const baseColors = colors.filter(({ name }) => name.startsWith('base-')).reverse()
    const colorGroups = colors.reduce<ColorGroup>((all, current) => {
      const currentGroup = all[current.value] ?? []
      currentGroup.push(current)
      all[current.value] = currentGroup
      return all
    }, {})

    return dedent`
		# \`${name}\` Theme

		This document shows the relationship of colors within the \`${name}\` theme. 

		${baseColors
      .map((groupColor) => {
        return dedent`
				## ${groupColor.name}
				\`\`\`mermaid
				graph RL
				${colorGroups[groupColor.value]
          .map(
            (color) =>
              `  ${color.name} --> ${
                color.attributes?.ref ?? `${color.original.rawValue}:::${groupColor.name}`
              }`,
          )
          .join('\n')}

					classDef ${groupColor.name} stroke-width:5,stroke:${groupColor.value}
				\`\`\`
			`
      })
      .join('\n')}
		`
  },
})

/**
 * Anything we're not actively using in the theme files or tailwind config should be filtered out
 *
 * If an asterisk appears in the token path that style will be filtered out here which gives us the ability
 * to explicitly filter things out directly from the token file
 */
StyleDictionary.registerFilter({
  name: 'unused-theme-tokens',
  matcher: (prop) => {
    return (
      ![
        'fontFamilies',
        'fontWeights',
        'fontSizes',
        'letterSpacing',
        'paragraphSpacing',
        'textCase',
        'textDecoration',
        'lineHeights',
      ].includes(prop.original.type) &&
      !prop.path.some((i) => i.includes('*')) &&
      !prop.name.endsWith('-uncased')
    )
  },
})

StyleDictionary.registerTransform({
  name: 'name/strip-default',
  type: 'name',
  transformer(token) {
    return token.name.replace(/(\w+-\w+)-default/, '$1')
  },
})

StyleDictionary.registerTransform({
  name: 'attribute/reference',
  type: 'attribute',
  matcher: (token) => token.original.type === 'color',
  transformer(token) {
    const ref = token.original.rawValue.match(/{(.+)}/)?.[1]?.replace(/\./g, '-')
    return { ...token.attributes, ref }
  },
})

StyleDictionary.registerTransform({
  name: 'attribute/alpha',
  type: 'attribute',
  matcher: (token) => token.original.type === 'color',
  transformer(token) {
    const alphaText = token.value.slice(7, 9)
    const alpha = alphaText && hexToRGB(alphaText)[0] / 255
    return { ...token.attributes, alpha, hasAlpha: typeof alpha === 'number' }
  },
})

StyleDictionary.registerTransform({
  name: 'pxToRem',
  type: 'value',
  matcher: (token) => ['borderRadius'].includes(token.original.type),
  transformer(token) {
    return `${token.value / 16}rem`
  },
})

const makeConfig = (theme: typeof THEMES[number]) => {
  const config: Config = {
    source: [`styles/src/.tokens/${theme}.json`],
    platforms: {
      web: {
        transforms: [
          'attribute/cti',
          'name/cti/kebab',
          'name/strip-default',
          'attribute/reference',
          'attribute/alpha',
          'pxToRem',
        ],
        buildPath: 'styles/dist/',
        files: [
          {
            filter: 'unused-theme-tokens',
            destination: `${theme}.css`,
            format: 'theme',
            options: {
              selector: theme === 'main' ? ':root' : `.${theme}-theme`,
            },
          },
          {
            filter: 'unused-theme-tokens',
            destination: `${theme}.md`,
            format: 'mermaid',
            options: {
              name: theme,
            },
          },
        ],
      },
    },
  }

  if (theme === 'main') {
    config.platforms.web.files?.push({
      filter: 'unused-theme-tokens',
      destination: `tailwind-tokens.js`,
      format: 'tailwind',
    })
  }

  return config
}

THEMES.forEach((theme) => {
  const sd = StyleDictionary.extend(makeConfig(theme))
  sd.buildAllPlatforms()
})
